/*
    Autor:      Marek Traczyński (261748)
    Kurs:       Języki Formalne i Techniki Translacji
    Projekt:    Kompilator
    Opis pliku: Parser
*/

%code requires { 
    #include "../astree.h"
    
    extern void yyerror(string s);
}

%{
    #include <iostream>
    #include <string>
    #include <vector>

    #include "../arithmetic.cpp"
    #include "../symtabnode.cpp"
    #include "../astree.cpp"


    using std::cout, std::vector;


    extern int yylineno;
    extern FILE* yyin;

    extern int yylex();
    extern int yyparse();
    extern void yyerror(string s);


    const string kColorReset = "\033[0m";
    const string kColorRed   = "\033[31m";
    const string kColorGreen = "\033[32m";

    extern vector<SymTabNode> symbolTable;
    extern vector<ASTree *> ASTreeTable;

    ASTree *globalTree;

    int argCount = 0;
%}



%union {
    int                     token;
    int                     tab_index;
    ASTree                  *astree;
    long long int           lli;
}


// Tokeny słów kluczowych
%token <token> T_PROCEDURE T_PROGRAM T_IS T_VAR T_BEGIN T_PROCCALL T_END
%token <token> T_IF T_THEN T_ELSE T_ENDIF
%token <token> T_WHILE T_DO T_ENDWHILE
%token <token> T_REPEAT T_UNTIL
%token <token> T_READ T_WRITE

// Tokeny znaków specjalnych
%token <token> T_LPAR T_RPAR
%token <token> T_ASSIGN T_COMMA T_SEMICOLON

// Tokeny znaków arytmetycznych
%token <token> T_ADD T_SUB T_MUL T_DIV T_MOD

// Tokeny znaków logicznych
%token <token> T_EQ T_NE T_GT T_LT T_GE T_LE

// Tokeny nieterminala value
%token <tab_index> T_IDENTIFIER T_NUM

// Token błędu
%token <token> T_ERROR


%type <astree> proc_call proc_head command declarations
%type <astree> condition expression value 


%%

program_all:
    procedures main     {
                            cout << "\n\nSymbol Table: ";
                            for (SymTabNode node : symbolTable)
                            {
                                cout << "\n>> Variable -> type: " << node.mNodeType 
                                     << "\tID: " << node.mNodeIdentifier 
                                     << "\t\tValue: " << node.mNodeValue 
                                     << "\tIndex: " << node.mNodeIndex
                                     << "\tParamCount: " << node.mNodeParamCount; 
                            }


                            cout << "\n\nASTree Vector:\n";
                            for (ASTree *tree : ASTreeTable)
                            {
                                printPreorder(tree, 0);
                            }

                        }
    ;

procedures:
    procedures T_PROCEDURE proc_head T_IS T_VAR declarations T_BEGIN commands T_END     
    | procedures T_PROCEDURE proc_head T_IS T_BEGIN commands T_END                      { 
                                                                                            // cout << "GLOBAL CURRENTPROC: " << currentProc; 
                                                                                            // currentProc.clear(); 
                                                                                        }
    |
    ;

main:
    T_PROGRAM T_IS T_VAR declarations T_BEGIN commands T_END
    | T_PROGRAM T_IS T_BEGIN commands T_END                     { 
                                                                    // cout << "GLOBAL CURRENTPROC: " << currentProc; 
                                                                    // currentProc.clear(); 
                                                                }
    ;

commands:
    commands command                                            {  ASTreeTable.push_back($2); }
    | command                                                   {  ASTreeTable.push_back($1); }
    ;

command:
    T_IDENTIFIER T_ASSIGN expression T_SEMICOLON                    { 
                                                                        if (!(($3->mTreeBranches).empty()))
                                                                        {
                                                                            ASTree *treeBranch1 = $3->mTreeBranches[0];
                                                                            ASTree *treeBranch2 = $3->mTreeBranches[1];

                                                                            switch($3->mTreeType) {
                                                                                case ASTree::kAddition:
                                                                                    symbolTable[$1].mNodeValue = symbolTable[treeBranch1->mTreeMemoryIndex].mNodeValue + 
                                                                                                                symbolTable[treeBranch2->mTreeMemoryIndex].mNodeValue;
                                                                                    break;
                                                                                case ASTree::kSubtraction:
                                                                                    symbolTable[$1].mNodeValue = symbolTable[treeBranch1->mTreeMemoryIndex].mNodeValue - 
                                                                                                                symbolTable[treeBranch2->mTreeMemoryIndex].mNodeValue;
                                                                                    break;
                                                                                case ASTree::kMultiplication:
                                                                                    symbolTable[$1].mNodeValue = symbolTable[treeBranch1->mTreeMemoryIndex].mNodeValue * 
                                                                                                                symbolTable[treeBranch2->mTreeMemoryIndex].mNodeValue;
                                                                                    break;
                                                                                case ASTree::kDivision:
                                                                                    symbolTable[$1].mNodeValue = symbolTable[treeBranch1->mTreeMemoryIndex].mNodeValue / 
                                                                                                                symbolTable[treeBranch2->mTreeMemoryIndex].mNodeValue;
                                                                                    break;
                                                                            }
                                                                        }
                                                                        else
                                                                        {
                                                                            symbolTable[$1].mNodeValue = symbolTable[$3->mTreeMemoryIndex].mNodeValue;
                                                                        }
                                                                        
                                                                        ASTree *variable = newTreeValue(ASTree::kIdentifier, $1); 
                                                                        $$ = newTreeStatement(ASTree::kAssign, variable, $3);
                                                                    }
    | T_IF condition T_THEN commands T_ELSE commands T_ENDIF
    | T_IF condition T_THEN commands T_ENDIF
    | T_WHILE condition T_DO commands T_ENDWHILE
    | T_REPEAT commands T_UNTIL condition T_SEMICOLON
    | proc_call T_SEMICOLON                                         { $$ = newTreeStatement(ASTree::kCallProcedure, $1); ASTreeTable.push_back($1); }
    | T_READ T_IDENTIFIER T_SEMICOLON                               { 
                                                                        ASTree *variable = newTreeValue(ASTree::kIdentifier, $2); 
                                                                        $$ = newTreeStatement(ASTree::kRead, variable);
                                                                    }
    | T_WRITE value T_SEMICOLON                                     { $$ = newTreeStatement(ASTree::kWrite, $2); }
    ;

proc_call:
    T_PROCCALL declarations T_RPAR              {
                                                    if (argCount != symbolTable[$1].mNodeParamCount) 
                                                    { 
                                                        string errorMsg = "Nieprawidłowa liczba argumentów dla procedury \'" + symbolTable[$1].mNodeIdentifier + "\'";
                                                        yyerror(errorMsg);
                                                    }

                                                    $$ = $2;
                                                }
    ;

proc_head:
    T_IDENTIFIER T_LPAR head_declarations T_RPAR    { 
                                                        // declareProc(*($1));
                                                    }
    ;

declarations:
    declarations T_COMMA T_IDENTIFIER           { 
                                                    argCount++; 

                                                    ASTree *variable = newTreeValue(ASTree::kIdentifier, $3); 
                                                    $$ = addDeclarations($1, variable);
                                                }
    | T_IDENTIFIER                              { 
                                                    argCount++; 

                                                    ASTree *variable = newTreeValue(ASTree::kIdentifier, $1); 
                                                    $$ = newTreeStatement(ASTree::kDeclarations, variable);
                                                }
    ;

head_declarations:
    head_declarations T_COMMA T_IDENTIFIER          { 
                                                        // addParam(*($3));
                                                    }
    | T_IDENTIFIER                                  { 
                                                        // addParam(*($1));
                                                    }
    ;

expression:
    value                           { $$ = $1; }
    | value T_ADD value             { $$ = newTreeStatement(ASTree::kAddition, $1, $3); }
    | value T_SUB value             { $$ = newTreeStatement(ASTree::kSubtraction, $1, $3);  }
    | value T_MUL value             { $$ = newTreeStatement(ASTree::kMultiplication, $1, $3);  }
    | value T_DIV value             { $$ = newTreeStatement(ASTree::kDivision, $1, $3);  }
    | value T_MOD value             { $$ = newTreeStatement(ASTree::kModulo, $1, $3);  }
    ;

condition:
    value T_EQ value                { $$ = newTreeStatement(ASTree::kEqual, $1, $3); }
    | value T_NE value              { $$ = newTreeStatement(ASTree::kNotEqual, $1, $3); }
    | value T_GT value              { $$ = newTreeStatement(ASTree::kGreater, $1, $3); }
    | value T_LT value              { $$ = newTreeStatement(ASTree::kLess, $1, $3); }
    | value T_GE value              { $$ = newTreeStatement(ASTree::kGreaterEqual, $1, $3); }
    | value T_LE value              { $$ = newTreeStatement(ASTree::kLessEqual, $1, $3); }
    ;

value:
    T_NUM                           { $$ = newTreeValue(ASTree::kNumber, $1); }
    | T_IDENTIFIER                  {
                                        if (symbolTable[$1].mNodeValue < 0) 
                                        { 
                                            string errorMsg = "Użycie niezadeklarowanej/niezainicjalizowanej zmiennej \'" + symbolTable[$1].mNodeIdentifier + "\'";
                                            yyerror(errorMsg);
                                        } 
                                        $$ = newTreeValue(ASTree::kIdentifier, $1); 
                                    }
    ;


%%



void yyerror(string s)
{
    std::cerr << kColorRed << "\n\t[ERROR] Linia nr " << yylineno << ": " << kColorGreen << s << kColorReset << "\n";
    exit(1);
}


void run_parser(FILE *file)
{
    cout << "Starting parsing...\n\n";

    yyin = file;

    yyparse();

    cout << "\n";
}