/*
    Autor:      Marek Traczyński (261748)
    Kurs:       Języki Formalne i Techniki Translacji
    Projekt:    Kompilator
    Opis pliku: Parser
*/

%code requires { 
    extern void yyerror(string s);
}

%{
    #include <iostream>
    #include <string>
    #include <vector>

    #include "../arithmetic.cpp"
    #include "../symtabnode.cpp"
    #include "../astree.cpp"


    using std::cout, std::vector;


    extern int yylineno;
    extern FILE* yyin;

    extern int yylex();
    extern int yyparse();
    extern void yyerror(string s);


    const string kColorReset = "\033[0m";
    const string kColorRed   = "\033[31m";
    const string kColorGreen = "\033[32m";

    extern vector<SymTabNode> symbolTable;

    int argCount = 0;
%}



%union {
    int                               token;
    int                               tab_index;
    long long int                     lli;
}


// Tokeny słów kluczowych
%token <token> T_PROCEDURE T_PROGRAM T_IS T_VAR T_BEGIN T_PROCCALL T_END
%token <token> T_IF T_THEN T_ELSE T_ENDIF
%token <token> T_WHILE T_DO T_ENDWHILE
%token <token> T_REPEAT T_UNTIL
%token <token> T_READ T_WRITE

// Tokeny znaków specjalnych
%token <token> T_LPAR T_RPAR
%token <token> T_ASSIGN T_COMMA T_SEMICOLON

// Tokeny znaków arytmetycznych
%token <token> T_ADD T_SUB T_MUL T_DIV T_MOD

// Tokeny znaków logicznych
%token <token> T_EQ T_NE T_GT T_LT T_GE T_LE

// Tokeny nieterminala value
%token <tab_index> T_IDENTIFIER T_NUM

// Token błędu
%token <token> T_ERROR


%type <lli> value expression


%%

program_all:
    procedures main     {
                            cout << "\nSymbol Table: ";
                            for (SymTabNode node : symbolTable)
                            {
                                cout << "\n>> Variable -> type: " << node.mNodeType 
                                     << "\tID: " << node.mNodeIdentifier 
                                     << "\t\tValue: " << node.mNodeValue 
                                     << "\tIndex: " << node.mNodeIndex
                                     << "\tParamCount: " << node.mNodeParamCount; 
                            }
                        }
    ;

procedures:
    procedures T_PROCEDURE proc_head T_IS T_VAR declarations T_BEGIN commands T_END     
    | procedures T_PROCEDURE proc_head T_IS T_BEGIN commands T_END                      { 
                                                                                            // cout << "GLOBAL CURRENTPROC: " << currentProc; 
                                                                                            // currentProc.clear(); 
                                                                                        }
    |
    ;

main:
    T_PROGRAM T_IS T_VAR declarations T_BEGIN commands T_END
    | T_PROGRAM T_IS T_BEGIN commands T_END                     { 
                                                                    // cout << "GLOBAL CURRENTPROC: " << currentProc; 
                                                                    // currentProc.clear(); 
                                                                }
    ;

commands:
    commands command
    | command
    ;

command:
    T_IDENTIFIER T_ASSIGN expression T_SEMICOLON                    { 
                                                                        symbolTable[$1].mNodeValue = $3; 
                                                                    }
    | T_IF condition T_THEN commands T_ELSE commands T_ENDIF
    | T_IF condition T_THEN commands T_ENDIF
    | T_WHILE condition T_DO commands T_ENDWHILE
    | T_REPEAT commands T_UNTIL condition T_SEMICOLON
    | proc_call T_SEMICOLON                     { cout << "func call"; }
    | T_READ T_IDENTIFIER T_SEMICOLON
    | T_WRITE value T_SEMICOLON
    ;

proc_call:
    T_PROCCALL declarations T_RPAR              {
                                                    if (argCount != symbolTable[$1].mNodeParamCount) 
                                                    { 
                                                        string errorMsg = "Nieprawidłowa liczba argumentów dla procedury \'" + symbolTable[$1].mNodeIdentifier + "\'";
                                                        yyerror(errorMsg);
                                                    } 
                                                }
    ;

proc_head:
    T_IDENTIFIER T_LPAR head_declarations T_RPAR    { 
                                                        // declareProc(*($1));
                                                    }
    ;

declarations:
    declarations T_COMMA T_IDENTIFIER           { argCount++; }
    | T_IDENTIFIER                              { argCount++; }
    ;

head_declarations:
    head_declarations T_COMMA T_IDENTIFIER          { 
                                                        // addParam(*($3));
                                                    }
    | T_IDENTIFIER                                  { 
                                                        // addParam(*($1));
                                                    }
    ;

expression:
    value                           { $$ = symbolTable[$1].mNodeValue; }
    | value T_ADD value             { $$ = COM_add(symbolTable[$1].mNodeValue, symbolTable[$3].mNodeValue); }
    | value T_SUB value             { $$ = COM_sub(symbolTable[$1].mNodeValue, symbolTable[$3].mNodeValue); }
    | value T_MUL value             { $$ = COM_mul(symbolTable[$1].mNodeValue, symbolTable[$3].mNodeValue); }
    | value T_DIV value             { $$ = COM_div(symbolTable[$1].mNodeValue, symbolTable[$3].mNodeValue); }
    | value T_MOD value             { $$ = COM_mod(symbolTable[$1].mNodeValue, symbolTable[$3].mNodeValue); }
    ;

condition:
    value T_EQ value
    | value T_NE value
    | value T_GT value
    | value T_LT value
    | value T_GE value
    | value T_LE value
    ;

value:
    T_NUM                           { $$ = $1; }
    | T_IDENTIFIER                  { 
                                        if (symbolTable[$1].mNodeValue < 0) 
                                        { 
                                            string errorMsg = "Użycie niezadeklarowanej zmiennej \'" + symbolTable[$1].mNodeIdentifier + "\'";
                                            yyerror(errorMsg);
                                        } 
                                    }
    ;


%%



void yyerror(string s)
{
    std::cerr << kColorRed << "\n\t[ERROR] Linia nr " << yylineno << ": " << kColorGreen << s << kColorReset << "\n";
    exit(1);
}


void run_parser(FILE *file)
{
    cout << "Starting parsing...\n\n";

    yyin = file;

    yyparse();

    cout << "\n";
}